>>>MOVIE TICKETS REFACTORING EXPLANATION

The purpose of this exercise is to take a previous exercise from Ch7 of the No Starch Python Crash Course Book (2ed), and refactor with new concepts.

Refactoring is when we take a program and improve the code, while maintaing the external behavior.

I will be providing a walkthrough for anyone that might want to follow this process step by step.

But, I am mostly including this to help me learn and actualize each step of my thought process.

This way, I can focus on not just the how of my code, but the why.

After all, we learn best by teaching.

First, let's take a look at the code from our original:

#!/usr/bin/env python3
# RyanWaltersDev Jun 15 2021 -- TIY 7-5

# Initial prompt
prompt = "\n\nThank you for choosing Runway Theaters!"
prompt += "\n(Type 'veteran' to see our discount options for service members.)"
prompt += "\n(If you are finished, please enter 'quit')"
prompt += "\n\nEnter the age of the person that this ticket is for: "

# while loop
active = True
ticket_list = []
while active:
    age = input(prompt)
    ticket = 0

    # integer input
    if age.isnumeric() == True:
        age = int(age)
        # younger than 3
        if age < 3:
            print(f"\n\tYour {age} year old child gets free admission!")
        # ages 3 to 12
        elif age >= 3 and age <= 12:
            print(f"\tThe ticket price for a {age} year old is $10!")
            ticket += 10
            ticket += ticket * 0.07
            ticket_list.append(ticket)
        # ages 12 to 64
        elif age > 12 and age < 65:
            print(f"\tThe ticket price for {age} year olds is $15!")
            ticket += 15
            ticket += ticket * 0.07
            ticket_list.append(ticket)
        # 65 and up
        elif age >= 65 and age < 120:
            print(f"\tThe price for our senior citizens is $12!")
            ticket += 12
            ticket += ticket * 0.07
            ticket_list.append(ticket)
        # Invalid age
        else:
            print("\tPlease enter a valid age.")

    # string input
    else:
        # quit break
        if age.title() == 'Quit' or age.title() == "'Quit'":
            break
        # veteran pricing
        elif age.title() == 'Veteran' or age.title() == "'Veteran'":
            print(f"\tThank you for your service. Your ticket price is $8!")
            ticket += 8
            ticket += ticket * 0.07
            ticket_list.append(ticket)
        # invalid response
        else:
            print("\tPlease enter a valid response.")
            continue

    # calculate ticket total
    total = 0
    for tickets in range(0, len(ticket_list)):
        total = total + ticket_list[tickets]
    print(f"\nYour current total is ${total}.")
    
    # ask to continue
    more_ticket = input("Would you like to buy more tickets? [Y/N] ")
    if more_ticket.title() == 'Y' or more_ticket.title() == 'Yes':
        continue
    else:
        print(f"\n\nThank you for choosing Runway Theaters! Enjoy the movie!")
        active = False

As we can see this file is too long, and the logic can be broken up into methods.

Let's switch branches and get started on refactoring this mess!

We used to the git checkout -b command to simultaneously create a new branch and switch two it.

The first thing we want to do is begin break down the logic of Python does when the user inputs an integer, so we name the branch integer_input.

Next, we want to create a module so that we can get some of the logic out of our main file.

In our first attempt we bit off more than we could chew, so let's break it down and go step by step.

First we will write the function that will run with a number that is less than 3.

For now, we are looking at price_calculator_2.py:

class PriceCalculator(): #1
    '''Calculate ticket price.'''

    def __init__(self, age): #2
        '''Initialize attributes.'''
        self.age = age

    def younger_than_3(self, age): #3
        '''Print message and add no price.'''
        return f"Your {self.age} year old child gets free admission!" #4

The first step is to create the class for our module, which we will call PriceCalculator().

The next step we need to initalize our attributes for the class using an __init__() method.

We then assign the variable age, the attribute of self, so that we can use it in other methods.

Next we define our first method, younger_than_3().

Because children under 3 are free we do not have to calculate any sort of price.

All we have to do is return the message that the child is free.

Now that we've written our simple function, let's make sure it works as we've expected!

Taking a look at our test module, price_calculator_test.py:

import unittest #1
from price_calculator_2 import PriceCalculator #1.5

class PriceCalculatorTest(unittest.TestCase): #2
    '''Make sure our price calculator works'''

    def test_younger_than_3(self): #3
        '''Check to make sure that function prints correctly'''
        age = PriceCalculator(2) #4
        child = age.younger_than_3(2) #5
        self.assertEqual(child, 'Your 2 year old child '
            'gets free admission!') #6

if __name__ == '__main__': #7
    unittest.main()

First thing we need to do is import the unittest Python module for testing.

Next we need to import our PriceCalculator class from price_calculator_2.py.

We do this by using the from file import class format.

Now we can set up our test class, and we have to make sure that we are inheriting TestCase from the unittest module.

At step 3, we define our first test method, test_younger_than_3(), which passes the attribute self.

NOTE: The first word of the method must be test, or no test will be run.

The next step is to set up an instance of PriceCalculator and call it age.

Then, we call the younger_than_3() method, pass it 2, and assign the result to child.

Because we return the string f'Your {self.age} year old child gets free admission!', we expect the out put to be:

'Your 2 year old child gets free admission!'

When we call assertEqual our second argument is the expected result, and the first argument is the result of the method call.

Before we can run the test, we have to tell Python to run it automatically when the test file is run as the main file at 7.

Python automatically assigns a __name__ to a file when a program is run. 

If it is imported, then it will not be assigned the __name__, '__main__'.

If the program is the main file, then the test will run.

Let's check the results of our test:

.
----------------------------------------------------------------------
Ran 1 test in 0.000s

OK

Bingo! We are looking good so far. 

Let's bring in another ticket pricing tier:

class PriceCalculator():
    --snip--

    def younger_than_3(self, age, ticket=0):
        --snip--

    def ages_3_to_12(self, age, ticket=0):
        '''Return ticket price and message for ages 3 to 12.'''
        ticket = 10
        return (ticket, f"The ticket price for a {age} year old is $10!")

    def ages_13_to_64(self, age, ticket=0):
        '''Return ticket price and message for ages 13 to 64.'''
        ticket = 15
        return(ticket, f"The ticket price for {age} year olds is $15!")

    def ages_65_and_older(self, age, ticket=0):
        '''Return ticket price and message for ages 65 and up.'''
        ticket = 12
        return(ticket, f"The ticket price for senior citizens is $12!")

So for each method we will pass three arguments, self, age, and ticket.

Notice how we set ticket to the default value of 0,

This is because we dont want to pass ticket when we call the method, but rather return the new value that we have assigned it to.

So we set ticket to equal our price for each tier and then return a tuple.

In order to return multiple values to a function we have to return them as a tuple, list, or dictionary.

The tuple we return has two values, the ticket price, and a message to be printed to the user.

Next, we should build some tests to make sure all of this works:

class PriceCalculatorTest(unittest.Testcase):
    --snip--

    def test_ages_3_to_12(self):
        '''Check funtion formula and return message.'''
        instance = PriceCalculator()
        customer = instance.ages_3_to_12(12)
        self.assertEqual(customer, (10, 
            "The ticket price for a 12 year old is $10!"))


    def test_ages_13_to_64(self):
        '''Check function formula and return message.'''
        instance = PriceCalculator()
        customer = instance.ages_13_to_64(25)
        self.assertEqual(customer, (15, 
            "The ticket price for 25 year olds is $15!"))

    def test_ages_65_and_older(self):
        '''Check function formula and return message.'''
        instance = PriceCalculator()
        customer = instance.ages_65_and_older(76)
        self.assertEqual(customer, (12,
            "The ticket price for senior citizens is $12!"))

These tests are set up in the exact same way, only changing the method call and the expected result.

First we define the test method and pass it the argument self.

Next we create an instance of PriceCalculator(),

And then we call the method that we are testing and assign the results to the variable customer.

Finally we use the assertEqual() test to compare the tuple to our expected result.

Let's see how our tests do:

....
----------------------------------------------------------------------
Ran 4 tests in 0.000s

OK

Looks like all 4 of our tests work and we can proceed to the next method.

What we want to do now is form some of the if statement logic for Python to determine which of these functions to call, based on the user input.

Here's what we came up with:

    def int_input_logic(self, age, tickets=[]):
        '''Return function based on age input and append ticket list.'''
        age = int(age)
        if age < 3:
            return self.younger_than_3(age)
        elif age >= 3 and age <= 12:
            result = self.ages_3_to_12(age)
            tickets.append(result[0])
            return tickets, result[0], result[1]
        elif age > 12 and age < 65:
            result = self.ages_13_to_64(age)
            tickets.append(result[0])
            return tickets, result[0], result[1]
        elif age >= 65 and age <=120:
            result = self.ages_65_and_older(age)
            tickets.append(result[0])
            return tickets, result[0], result[1]
        else:
            return (0, [], "Please enter a valid age.")

Notice the difference in the arguments passed for this method.

First, we no longer pass the ticket bc we expect this value to be returned from our method calls.

Next, we want to pass a new parameter, tickets, and set it equal to an empty list.

This is so that we can calculate ticket totals later, and it is easiest to do this now.

Because our variable age is going to be compared to other integers, we should make sure that it is an integer and not a string.

Next we open our if statement.

If the age is less than 3, we return our younger_than_3 method call, and pass the age.

If the age is between 3 and 12 (or equal to), we move to the next tier.

First we need to call the method and assign the results to a variable, so that we can append our list with the ticket price (which is stored in the first index of the tuple).

Then we append the list tickets with the ticket price from the result of our method call.

Finally, in each code block, we return a new tuple that contains out values in the following order: tickets[], ticket, string

Let's write a test for this method to make sure everything works:

    def test_int_input_logic(self):
        '''Check tuple output of function.'''
        instance = PriceCalculator()
        tickets, ticket, string = instance.int_input_logic(12)
        self.assertEqual(tickets, [10])
        self.assertEqual(ticket, 10)
        self.assertEqual(string, "The ticket price for a 12 year old is $10!")

After we define the test method and pass it self, we can start building our test.

First thing we want to do is create an instance of PriceCalculator.

Next by separating each variable by commas, we can call our int_input_logic() method and assign each part of the tuple to a variable respectively.

Finally we use the assertEqual method, this time for each part of the tuple, to make sure that each respective variable is correct:

.....
----------------------------------------------------------------------
Ran 5 tests in 0.000s

OK

